---
title: <오라클 성능 고도화 원리와 해법1> Ch02-03 비관적 vs. 낙관적 동시성 제어
date: 2024-02-20T15:15:00
categories: sql tuning
---

### 오라클 성능 고도화 원리와 해법1 - Ch02 트랜잭션과 Lock - 03 비관적 vs. 낙관적 동시성 제어

동시성제어를위해, 앞에서설명한트랜잭션고립화수준을변경하는DBMS기능을 사용할수없는경우가있다. 특히, n- Ter 구조가지배적인요즘같은개발환경에서더
욱그렇고, 그럴때는트랜잭션의동시성제어를개발자가직접구현해야만한다. 

동시성제어는비관적동시성제어와낙관적동시성제어로나뉜다.

비관적동시성제어(Pessinisic ConcurencyContra)는사용자들이같은데이터를동시에 수정
할것이라고가정한다. 따라서한사용자가데이터를읽는시점에Lock을걸고조회또는 갱신처리가완료될때까지이를유지한다. Locking은첫번째사용자가트랜잭션을완료 하기 전까지 다른 사용자들이 그 데이터를 수정할 수없게 만들기 때문에 비관적 동시성
제어를잘못사용하면동시성을저해받게된다. "잘못사용하면"이라고한데에주목하 자. 잘사용하면약이될수도있다는뜻이며글을계속읽다보면이해하게될것이다.

반 면 , 낙 관 적 동 시 성 제 어 ( O p i mi s i c C o r e u r e n c y C o n t r a ) 는 사 용 자 들 이 같 은 데 이 터 를 동 시 에 수정하지않을것이라고가정한다. 따라서데이터를읽을때는Look을설정하지않는다.
그런데낙관적입장에섰다고해서동시트랜잭션에의한데이터의잘못된갱신을신경
쓰지않아도된다는것은절대아니다. 읽는시점에Lock을사용하지않았지만, 데이터 를수정하고자하는시점에앞서읽은데이터가다른사용자에의해변경되었는지를반
드시검사해야한다.

낙관적동시성제어를사용하면Lock이유지되는시간이매우짧아져동시성을높이
는데에유리하다. 하지만다른사용자가같은데이터를변경했는지검사하고그에따라 분기해나가야하는귀찮은처리절차가뒤따른다. 정말귀찮아서일까, 아니면동시성제 어의필요성을몰라서일까? 튜닝을다니면서개발팀에서작성한SOL들을많이분석하 게되는데,'낙관적동시성제어' 를해야하는상황에서대부분'동시성제어없는낙관
적프로그래밍' 을하고있다.

예를들어, 온라인쇼핑몰에서특정상품을조회해서주문을시작하고결제를완료하
는순간까지를하나의트랜잭션으로정의했다고가정하자. 상품조회시에는1,000원이 었던 상품이주문을진행하는동안가격이수정돼서결제를완료하는순간에는1,200원
일수있다. 따라서최종결제버튼을클릭하는순간상품가격의변경여부를체크하고, 변경되었다면 해당 주문을 취소시키거나 사용자에게 변경사실을 알리 고처리방향을 확
인받는프로세스를거쳐야만한다. 물론업무적으로' 주문' 을시작하는시점의가격을기 준으로주문을처리하는것이옳다면 그에맞는단계에서일관성체크를해서처리하면 된다.

(ing)
