---
title: <오라클 성능 고도화 원리와 해법1> Ch02-03 비관적 vs. 낙관적 동시성 제어
date: 2024-02-20
categories: sql tuning
---

### 오라클 성능 고도화 원리와 해법1 - Ch02 트랜잭션과 Lock - 03 비관적 vs. 낙관적 동시성 제어

동시성 제어를 위해, 앞에서 설명한 트랜잭션 고립화 수준을 변경하는 DBMS 기능을 사용할 수 없는 경우가 있다. 특히, n-Tier 구조가 지배적인 요즘 같은 개발 환경에서 더욱 그렇고, 그럴 때는 트랜잭션의 동시성 제어를 개발자가 직접 구현해야만 한다.

동시성 제어는 비관적 동시성 제어와 낙관적 동시성 제어로 나뉜다.

비관적 동시성 제어(Pessimistic Concurrency Control)는 사용자들이 같은 데이터를 동시에 수정할 것이라고 가정한다. 따라서 한 사용자가 데이터를 읽는 시점에 Lock을 걸고 조회 또는 갱신 처리가 완료될 때까지 이를 유지한다. Locking은 첫 번째 사용자가 트랜잭션을 완료하기 전까지 다른 사용자들이 그 데이터를 수정할 수 없게 만들기 때문에 비관적 동시성 제어를 잘못 사용하면 동시성을 저해받게 된다. "잘못 사용하면"이라고 한 데에 주목하자. 잘 사용하면 약이 될 수도 있다는 뜻이며 글을 계속 읽다 보면 이해하게 될 것이다.

반면, 낙관적 동시성 제어(Optimistic Concurrency Control)는 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정한다. 따라서 데이터를 읽을 때는 Lock을 설정하지 않는다. 그런데 낙관적 입장에 섰다고 해서 동시 트랜잭션에 의한 데이터의 잘못된 갱신을 신경 쓰지 않아도 된다는 것은 절대 아니다. 읽는 시점에 Lock을 사용하지 않았지만, 데이터를 수정하고자 하는 시점에 앞서 읽은 데이터가 다른 사용자에 의해 변경되었는지를 반드시 검사해야 한다.

낙관적 동시성 제어를 사용하면 Lock이 유지되는 시간이 매우 짧아져 동시성을 높이는 데에 유리하다. 하지만 다른 사용자가 같은 데이터를 변경했는지 검사하고 그에 따라 분기해 나가야 하는 귀찮은 처리 절차가 뒤따른다. 정말 귀찮아서일까, 아니면 동시성 제어의 필요성을 모르는 것일까? 튜닝을 다니면서 개발 팀에서 작성한 SQL들을 많이 분석하게 되는데, '낙관적 동시성 제어'를 해야 하는 상황에서 대부분 '동시성 제어 없는 낙관적 프로그래밍'을 하고 있다.

예를 들어, 온라인 쇼핑몰에서 특정 상품을 조회해서 주문을 시작하고 결제를 완료하는 순간까지를 하나의 트랜잭션으로 정의했다고 가정하자. 상품 조회 시에는 1,000원이었던 상품이 주문을 진행하는 동안 가격이 수정돼서 결제를 완료하는 순간에는 1,200원일 수 있다. 따라서 최종 결제 버튼을 클릭하는 순간 상품 가격의 변경 여부를 체크하고, 변경되었다면 해당 주문을 취소시키거나 사용자에게 변경 사실을 알리고 처리 방향을 확인받는 프로세스를 거쳐야만 한다. 물론 업무적으로 '주문'을 시작하는 시점의 가격을 기준으로 주문을 처리하는 것이 옳다면 그에 맞는 단계에서 일관성 체크를 해서 처리하면 된다.

![](/assets/images/sqlp/sqlp-1-02-03-0.png)


(ing..)


