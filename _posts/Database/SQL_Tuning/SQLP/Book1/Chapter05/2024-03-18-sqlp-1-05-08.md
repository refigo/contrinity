---
title: <오라클 성능 고도화 원리와 해법1> Ch05-08 PL/SQL 함수 호출 부하 해소 방안
date: 2024-03-18
categories: sql tuning
---


### 오라클 성능 고도화 원리와 해법1 - Ch05-08 PL/SQL 함수 호출 부하 해소 방안

**다시 한 번 강조하지만, 사용자 정의 함수는 <① 소량의 데이터 조회 시에만 사용>하는 것이 좋다. <② 대용량 데이터를 조회할 때는 부분범위 처리 가능한 상황에서 제한적으로 사용>해야 하며, 되도록이면 <③ 조인 또는 스칼라 서브쿼리 형태로 변환하려는 노력이 필요>하다. 그런데, 구현상 복잡성으로 인해 함수를 도저히 풀 수 없는 경우가 자주있다. <④ 어쩔 수 없을 때는 함수를 쓰되 호출 횟수를 최소화할 수 있는 방법을 강구>해야 한다.**

지금부터 설명할 함수 호출 부하 해소 방안을 요약하면 다음과 같다.

- 페이지 처리 또는 부분 범위 처리 활용
- Decode 함수 또는 Case문으로 변환
- 뷰 머지(View Merge) 방지를 통한 함수 호출 최소화
- 스칼라 서브쿼리 캐싱 효과를 이용한 함수 호출 최소화
- Deterministic 함수의 캐싱 효과 활용
- 복잡한 함수 로직을 풀어 SQL로 구현

#### (1) 페이지 처리 또는 부분범위처리 활용

튜닝 컨설팅을 다니면서 함수 부하 때문에 개발팀에 가장 많이 가이드하는 튜닝 사례는 아래와 같은 경우다.

![](/assets/images/sqlp/sqlp1-05-08-1-sql1.png)

사실 위 케이스는 함수를 꼭 사용해야만 하는 경우는 아니다. 그런데도 개발 초기에 정해진 표준 규칙에 따라, 코드명을 가져올 때는 함수를 써야만 하는 상황이었다고 가정하자. (가정이라지만 실제 이런 상황에 자주 직면하게된다.)


위처럼 쿼리를 작성하면 최종 결과 건수가 얼마건 간에 조건절에 부합하는 전체 레코드 건수만큼 함수 호출을 일으키고`50)`, 그 결과 집합을 Sort Area 또는 Temp 테이블 스페이스에 저장한다. 그리고 최종 결과 집합 10건만을 사용자에게 전송하게 된다.

>	50) 2권에서 설명하지만, 조건절과 order by절에 딱 맞게 인덱스가 구성돼 있으면 Sort가 발생하지 않는다. 그럴 때는 부분 범위 처리 방식으로 수행 가능하다.

**아래 처럼 쿼리를 바꾸면, order by 와 rownum에 의한 필터 처리 후 사용자에게 전송하는 최종 결과 집합에 대해서만 함수 호출이 일어난다. 요즘 같은 n-Tier 환경에서는 페이지 처리가 필수다 보니 가장 흔히 접하게 되는 튜닝 사례이므로 반드시 숙지해서 실무에 적용하기 바란다.**

![](/assets/images/sqlp/sqlp1-05-08-1-sql2.png)

**페이지 처리를 하지 않더라도 부분 범위 처리가 가능한 상황이라면 클라이언트에게 데이터를 전송하는 맨 마지막 단계에 함수 호출이 일어나도록 함(-> 위와 같이 맨 바깥쪽 select-list에 함수를 기술하면 됨)으로써 큰 성능 개선을 이룰 수 있다.**

#### (2) Decode 함수 또는 Case문으로 변환

**함수가 안쪽 인라인 뷰에서 order by절에 사용된다든가, 전체 결과 집합을 모두 출력하거나, insert...select 문에서 사용된다면 다량의 함수 호출을 피할 수 없다. 그럴 때는 함수 로직을 풀어서 decode, case문으로 전환하거나 조인문으로 구현할 수 있는지 먼저 확인해야 한다. 함수 로직이 복잡하거나 프로젝트 규칙상 함수를 사용해야만 한다면 함수에 입력되는 값의 종류가 얼마나 되는지 확인해보기 바란다. 만약 값의 종류가 많지 않다면 함수를 그대로 둔 채 스칼라 서브쿼리의 캐싱 효과를 이용하는 것만으로도 큰 효과를 볼 수 있기 때문이다.**

물론 함수를 사용하는데 따른 장점도 있다. 함수를 사용하면 분류체계가 바뀌더라도 SQL들을 찾아 일일이 바꾸지 않아도 된다. 함수 내용만 바꿔주면 되기 때문이다. **하지만 굳이 함수를 이용하지 않더라도 정보 분류 및 업무 규칙, 규정들을 테이블화해서 관리한다면 매번 쿼리를 바꾸지 않고도 함수가 갖는 장점들을 그대로 가져올 수 있다.** 지금 보고 있는 사례에서 상품 분류가 바뀔 수 있다면 아래처럼 시장 코드와 증권 그룹 코드별 분류명을 메타 정보로써 관리하는 테이블을 만들어 사용하면 된다.

분류 순서 테이블과의 조인 때문에 성능이 느려질 것이라고 생각했을지 모르지만 전혀 그렇지 않았다. 0.68초만에 수행된 것을 볼 수 있다. 100만 건 그대로 조인을 실시하면 당연히 느려지겠지만(이 역시도 해시 조인으로 처리하면 빠르게 수행된다.) group by를 먼저 수행해 20건으로 압축된 결과 집합을 가지고 조인하므로 성능을 전혀 떨어뜨리지 않는다.

