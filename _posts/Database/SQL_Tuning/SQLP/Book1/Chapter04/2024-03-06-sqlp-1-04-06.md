---
title: <오라클 성능 고도화 원리와 해법1> Ch04-06 바인드 변수의 부작용과 해법
date: 2024-03-06
categories: sql tuning
---


### 오라클 성능 고도화 원리와 해법1 - Ch04-06 바인드 변수의 부작용과 해법

바인드 변수 사용과 관련해 꼭 알아야 할 중요한 사실이 있다. 앞선 그림 4-5에서 본 SQL 수행 절차를 다시 상기해보자.

![](/assets/images/sqlp/sqlp1-04-06-img4-5.png)

바인드 변수를 사용하면 처음 수행할 때 최적화를 거친 실행 계획을 캐시에 저장하고, 실행 시점에는 그것을 그대로 가져와 값을 다르게 바인딩하면서 반복 재사용하게 된다. **여기서 중요한 점은 변수를 바인딩하는 시점이 (최적화 시점보다 나중인) 실행 시점이라는 것이다. 즉, SQL을 최적화하는 시점에 조건절 컬럼의 데이터 분포도를 활용하지 못하는 문제점을 갖는다.** (바인드 변수를 사용하면 통계 정보를 사용하지 못한다고 흔히 말하지만, 정확히는 컬럼 히스토그램 정보를 사용하지 못한다는 것이다. 히스토그램을 제외한 다른 통계 정보들은 충분히 활용한다.)

**따라서 바인드 변수를 사용할 때 옵티마이저는 평균 분포를 가정한 실행 계획을 생성한다. 컬럼 분포가 균일할 때는 문제될 것이 없지만 그렇지 않을 때는 실행 시점에 바인딩되는 값에 따라 최적이 아닌 실행 계획이 될 수 있어 문제다.**

**특히, 등치(=) 조건이 아닌 부등호나 Between 같은 범위 기반 검색 조건일 때는 고정된 규칙을 사용하기 때문에 더 부정확한 예측에 기반한 실행 계획이 만들어진다.** 좀 더 구체적으로 말해, 아래 1~4번은 선택도(Seletivity)를 5%로 계산하고, 5~8번까지는 0.25%로 계산한다.

![](/assets/images/sqlp/sqlp1-04-06-table1.png)

2권에서 설명하겠지만 비용 계산에 기초가 되는 카디널리티(Cardinality, 특정 액세스 단계를 거치고나서 출력될 것으로 예상되는 결과 건수)는 전체 레코드 수에 선택도를 곱해서 구한다.

`카디널리티(Cardinality) = 선택도(Selectivity) X 전체 레코드 수`

따라서 테이블에 1,000개 로우가 있을 때 옵티마이저는 1~4번과 같은 조건절에 대해서는 50개 로우이 출력될 것으로 예상하고, 5~8번과 같은 조건절에 대해서는 3개 로우가 출력될 것으로 예상한다. 아래 테스트 결과에서 이런 사실을 쉽게 확인할 수 있다.

![](/assets/images/sqlp/sqlp1-04-06-test1.png)

바인드 변수를 사용했을 때 옵티마이저는 각각 50개와 3개의 카디널리티(rows)를 예상하였다. 사용자가 실제 입력한 값에 따라 전혀 결과가 달라질 수 있지만 옵티마이저로서는 어쩔 수 없는 선택을 한 것이다.

**반면, 아래처럼 상수 조건식(no <= 100, no between 500 and 600)을 사용했을 때는 거의 정확한 카디널리티를 계산해 낸다.**

![](/assets/images/sqlp/sqlp1-04-06-test2.png)

**이처럼 바인드 변수를 사용할 때는 정확한 컬럼 히스토그램에 근거하지 않고 카디널리티를 구하는 정해진 계산식에 기초해 비용을 계산하므로 최적이 아닌 실행 계획을 수립할 가능성이 높다.**

바인드 변수를 사용하면 컬럼 히스토그램을 제대로 활용하지 못할 뿐만 아니라 파티션 테이블을 쿼리할 때 파티션 레벨 통계 정보를 이용하지 못하는 것도 바인드 변수의 대표적인 부작용 중 하나다. 파티션 레벨 통계보다 다소 부정확한 테이블 레벨 통계를 이용함으로써 옵티마이저가 가끔 악성 실행 계획을 수립한다.

#### (1) 바인드 변수 Peeking

바인드 변수의 부작용을 극복하기 위해 오라클은 9i부터 바인드 변수 Peeking 기능을 도입했다. 'Peeking'이라는 단어가 의미하듯, 이 기능은 SQL이 첫 번째 실행될 때 하드 파싱될 때 함께 딸려 온 바인드 변수 값을 살짝 훔쳐보고, 그 값에 대한 컬럼 분포를 이용해 실행 계획을 결정하는 것이다. 다른 DBMS에서도 같은 기능을 제공하는데, 예를 들어 SQL Server에서는 'Parameter Sniffing'이라고 부른다`38)`.

>	38) sniff: 냄새를 맡다. 냄새로 알아채다.

**그런데 이것은 매우 위험한 기능이 아닐 수 없다. 어제까지 잘 돌던 프로그램이 어느 날 갑자기 느려지는 현상이 발생할 수 있기 때문이다.** 예를 들어, 아파트 매물 분포가 그림 4-8과 같다고 하자.

아직 인덱스 원리에 대해 설명하지 않았지만, 서울시와 경기도처럼 선택도(Selectivity)`39)`가 높은 데이터를 인덱스를 경유해 액세스할 때면 성능이 오히려 더 느려진다는 사실만큼은 잘 알고 있을 것이다.

>	39) 전체 데이터 중 조회 조건으로 입력된 값에 의해 선택되는 비율을 말한다.

![](/assets/images/sqlp/sqlp1-04-06-1-img4-8.png)

`SELECT * FROM 아파트 매물 WHERE 도시 = :CITY;`

아파트 매물을 검색하는 위 쿼리가 처음 수행되는 시점에 사용자가 '서울시' 또는 '경기도'를 입력했다면, 옵티마이저는 아마 테이블을 Full Scan 하는 실행 계획을 수립할 것이다. **그러면 이 실행 계획이 캐시에서 밀려나기 전까지는 '제주도'가 입력되든 '강원도'가 입력되든 항상 테이블을 Full Scan 하게 된다.** (참고로, Bind 변수 Peeking에 사용된 값보다 아주 긴 값이 입력되면 실행 계획을 다시 수립하는 기회를 얻게 된다. 하지만 이 사례에서는 해당 사항이 없는 것 같다. 4절 '커서 공유' 중 '(3) 커서를 공유하지 못하는 경우'를 참조하기 바란다.)

그 다음날 쿼리가 처음 수행될 때는 사용자가 우연히 '제주도'를 입력했다. 그러면 Index Range Scan을 통해 테이블을 액세스하는 실행계획을 수립하게 되고, 그 이후에는 계속해서 같은 방식으로 수행된다. 서울시와 경기도 매물이 많다면 검색이 이루어지는 비중도 그럴 텐데, 실행 계획이 캐시에서 밀려나기 전까지 이 애플리케이션에서 서울시와 경기도 매물을 검색하는 사용자는 예전보다 느려진 성능 때문에 짜증을 느끼게 된다.

**그리고 이 쿼리의 수행 빈도가 낮아 캐시에서 자주 밀려난다면 하루 중에도 실행 계획이 수시로 바뀔 수 있으니 이 또한 문제가 아닐 수 없다.**

**그런데 10g부터 dbms_stats의 기본 설정이 히스토그램을 생성할지 여부를 오라클이 판단하는 쪽으로 바뀌었다. 이전에는 히스토그램을 전혀 생성하지 않거나 몇몇 개만 생성했던 것이 10g부터는 더 많은 컬럼에 히스토그램이 생성됨으로 말미암아 바인드 변수 Peeking에 의한 폐해가 더 도드라져 보이게 되었다.**

**잘못 수립된 실행 계획 때문에 느린 애플리케이션도 문제지만 시스템 운영자 입장에서는 자주 실행 계획이 바뀌어 어제와 오늘의 수행 속도가 급격히 달라지는 현상을 더 민감하게 받아들일 수밖에 없다. 차라리 항상 느린 애플리케이션이라면 튜닝을 통해 해결할 수 있어 더 낫다.**

또한, 바인드 변수 Peeking 기능이 활성화되었어도 Explain Plan 명령을 통해 확인하는 사전 실행 계획은 이 기능이 적용되지 않은 실행 계획임을 주의할 필요가 있다. **Explain Plan 명령을 통해 실행 계획을 확인할 때는 바인드 값을 제공하지 않으므로 옵티마이저는 바인드 값을 Peeking할 수 없다. 당연히 이때의 실행 계획은 평균 분포를 가정한 실행 계획일 테고, 그 실행 계획을 확인하고 배포한 SQL이 실제 실행 시점에는 바인드 변수 Peeking을 일으켜 다른 방식으로 수행될 수 있다.**

이런저런 연유로, 바인드 변수 Peeking 기능을 개발한 오라클 개발팀 입장에서는 안타까운 일이지만 **현재 대부분 운영 시스템에서는 아래처럼 이 기능을 비활성화시킨 상태에서 운영 중이다.**

`alter system set "_optim_peek_user_binds"=FALSE;`

