---
title: <오라클 성능 고도화 원리와 해법1> Ch02-05 오라클 Lock
date: 2024-02-22
categories: sql tuning
---


### 오라클 성능 고도화 원리와 해법1 - Ch02 트랜잭션과 Lock - 05 오라클 Lock

오라클은 공유 리소스와 사용자 데이터를 보호할 목적으로 DML Lock, DDL Lock, 래치(Latch), 버퍼 Lock, 라이브러리 캐시 Lock/Pin 등 다양한 종류의 Lock을 사용한다. 여기에는 내부적으로 더 많은 종류의 Lock이 존재한다.

이 중 래치와 버퍼 Lock에 대해서는 1장에서 다루었다.

- **래치**: SGA에 공유된 갖가지 자료구조를 보호할 목적으로 사용하는 가벼운 Lock
- **버퍼 Lock**: 버퍼 블록에 대한 액세스를 직렬화

라이브러리 캐시 Lock과 라이브러리 캐시 Pin에 대해서는 4장과 부록에서 자세히 다루지만, 간단히 설명하면 라이브러리 캐시에 공유된 오브젝트 정의, 커서, PL/SQL 프로그램 같은 실행 가능 오브젝트에 대한 정의 및 실행 계획을 보호하는 Lock이다.

- **라이브러리 캐시 Lock**: 라이브러리 캐시 오브젝트에 대한 핸들을 보호
- **라이브러리 캐시 Pin**: 라이브러리 캐시 오브젝트의 실제 내용이 담긴 힙(Heap)을 보호

애플리케이션 개발 측면에서 가장 중요하게 다루어야 할 Lock은 DML Lock이다. 본 절에서 집중적으로 설명하려고 하는 DML Lock은, 다중 사용자에 의해 동시에 액세스되는 사용자 데이터의 무결성을 보호해준다. DML Lock에는 테이블 Lock과 로우 Lock이 있다.

- **DML 테이블 Lock**: Enqueue Lock으로 구현됨
- **DML 로우 Lock**: 로우 단위 Lock과 트랜잭션 Lock을 조합해서 구현됨(트랜잭션 Lock은 Enqueue Lock으로 구현)

DML Lock을 이해하려면 Enqueue Lock 구조와 트랜잭션 Lock(TX Lock) 개념을 먼저 이해해야 한다. 본 절에서 설명할 내용을 미리 열거하면 다음과 같다.

1. **Enqueue Lock**
2. **TX Lock (= 트랜잭션 Lock)**
3. **TX Lock ▶︎ 무결성 제약 위배 가능성 또는 비트맵 인덱스 엔트리 갱신**
4. **TX Lock ▶︎ ITL 슬롯 부족**
5. **TX Lock ▶︎ 인덱스 분할**
6. **TX Lock N ▶︎ 기타 트랜잭션 Lock**
7. **TX Lock ▶︎ DML 로우 Lock**
8. **TM Lock ▶︎ DML 테이블 Lock**
9. **Lock을 푸는 열쇠, 커밋**


#### (1) Enqueue Lock

Enqueue는 공유 리소스에 대한 액세스를 관리하는 Lock 메커니즘이다. Enqueue에 의해 보호되는 공유 리소스로는 테이블, 트랜잭션, 테이블스페이스, 시퀀스, Temp 세그먼트 같은 것들이 있다. Enqueue Lock은 래치와 달리 순서가 보장되는 큐(Queue) 구조를 사용한다. 따라서 대기자 큐(Queue)에 가장 먼저 Lock 요청을 등록한 세션이 가장 먼저 Lock을 획득한다.

Enqueue Lock으로 관리되는 공유 리소스에 대해 Lock을 획득하려면 먼저 'Enqueue 리소스'를 할당받아야 한다. Enqueue 리소스는 소유자(owner), 대기자(waiter) 목록을 관리할 수 있는 구조체(Structure)를 말한다. 각 Enqueue 리소스에는 고유한 식별자가 부여되며, 식별자는 \<Type-ID1-ID2\>로 구성된다. Type은 'TX', 'TM', 'TS'처럼 2개 문자열로 이루어지며, ID1, ID2에는 Lock 종류에 따라 다른 정보를 갖는다. 예를 들어, TM Lock 식별자에는 다음과 같은 정보를 포함한다.

- **TYPE**: TM
- **ID1**: 오브젝트 ID
- **ID2**: 0

TX Lock 식별자에는 다음과 같은 정보를 포함한다.

- **TYPE**: TX
- **ID1**: Undo 세그먼트 번호 + 트랜잭션 슬롯 번호
- **ID2**: 트랜잭션 슬롯 Sequence 번호

오라클은 Enqueue 리소스 구조체를 통합 관리하는 리소스 테이블(일종의 Array)을 갖고 있으며, 리소스 테이블에서 관리되는 각 리소스를 찾을 때는 해싱 알고리즘을 사용한다. 물론, 해싱을 위한 해시 키(Hash Key)로는 리소스 식별자가 사용된다. 각 해시 버킷에는 연결 리스트(Linked List)로 연결된 해시 체인을 가지며, 여기에 리소스 구조체가 연결된다(그림 2-4).

![](/assets/images/sqlp/sqlp-1-02-04.png)

Enqueue 방식으로 관리되는 특정 리소스(테이블, 트랜잭션)에 대해 Lock을 획득하려면, 먼저 리소스 테이블에서 해당 리소스 구조체를 찾는다. 리소스 구조체를 찾지 못하면, 새로운 리소스 구조체를 할당받아 해시 체인 연결 리스트에 연결한다. 그런 후, 리소스 구조체의 소유자 목록에 자신을 등록하면 된다. 호환되지 않는 모드로 먼저 Lock을 획득한 (즉, 소유자 목록에 등록된) 세션이 있다면 Lock 요청을 대기자 목록에 등록하고 대기해야 한다. (또는 작업을 포기하는 선택을 할 수도 있다.)

소유자가 Exclusive 모드일 때는 한 순간에 하나의 세션만 Lock을 획득할 수 있지만, Shared 모드일 때는 여러 세션이 동시에 Lock을 획득할 수 있다. 즉, 여러 세션이 동시에 소유자 목록에 등록될 수 있다. 소유자 목록에 Shared 또는 Exclusive 모드 Lock이 등록된 상태에서 Exclusive 모드로 Lock을 획득하려는 세션은 대기자 목록에서 대기해야 하며, 하나의 리소스 구조체 대기자 목록에 동시에 여러 세션이 등록된 상태로 대기할 수도 있다. Enqueue Lock의 작동 메커니즘은 아래와 같다.

1. 세션 A가 Shared 모드로 Lock을 획득한다.
2. 세션 B가 Shared 모드로 Lock을 획득하려고 한다. 먼저 Lock을 소유한 세션 A와 호환되므로 정상적으로 Lock을 획득한다. 이제 소유자 목록에는 두 개 세션이 달려 있다.
3. 세션 C가 Exclusive 모드로 Lock을 획득하려고 한다. Shared 모드와 Exclusive 모드 간에 호환성이 없으므로 대기자 목록에 자신을 등록하고 대기한다.
4. 소유자 목록에 Shared 모드로 달려있던 세션 A와 B가 모두 Lock을 해제하면 세션 C가 Exclusive 모드로 소유자 목록에 등록된다.
5. 세션 A가 Exclusive 모드로 다시 Lock을 획득하려고 하면, Exclusive 모드와 호환되지 않으므로 대기자 목록에 자신을 등록하고 대기한다.
6. 세션 B가 다시 Shared 모드로 Lock을 획득하려고 할 때도 Exclusive 모드와 호환되지 않으므로 대기자 목록에 자신을 등록하고 대기한다.
7. Enqueue Lock은 순서가 보장되므로 세션 C가 Lock을 해제하면 세션 A가 가장 먼저 Exclusive 모드로 Lock을 획득한다.


#### (2) TX Lock (트랜잭션 Lock)

트랜잭션을 시작하려면 먼저 Undo 세그먼트 헤더에 위치한 트랜잭션 테이블로부터 슬롯(Slot)을 하나 할당받아야 한다고 1장에서 설명했다. 이 트랜잭션이 변경을 가한 블록에 대한 Consistent 버전을 얻으려는 다른 트랜잭션은, 트랜잭션 슬롯에 기록된 상태 정보를 확인하고, 필요하다면 CR 블록을 생성해서 읽는다. 그렇게 함으로써 오라클은, 레코드가 갱신 중이더라도 읽기 작업에 대해서는 블로킹 없이 작업을 진행할 수 있도록 구현하였다.

하지만 변경 중인 레코드(또는 기타 리소스)를 동시에 변경하려는 트랜잭션에 대해서는 액세스를 직렬화해야 하며, 그 목적으로 사용하는 Lock 메커니즘이 트랜잭션 Lock(이하 TX Lock)이다. TX Lock은 트랜잭션이 첫 번째 변경을 시작할 때 얻고, 커밋 또는 롤백할 때 해제한다.

TX Lock도 Enqueue Lock으로 구현되었다. 앞에서 설명했듯이 TX Lock을 위한 Enqueue 리소스 구조체의 식별자는 다음과 같은 정보를 포함한다:

- **TYPE**: TX
- **ID1**: Undo 세그먼트 번호 + 트랜잭션 슬롯 번호
- **ID2**: 트랜잭션 슬롯 Sequence 번호

이 식별자를 갖는 리소스 구조체를 Enqueue 리소스 테이블 해시 체인에 연결하고, 소유자 목록에 트랜잭션을 등록함으로써 Lock을 획득한다. 이제 TX Lock을 획득했으므로 트랜잭션을 위한 일련의 작업들을 수행할 수 있다.

TX Lock 메커니즘을 그림 2-5를 보면서 이해해 보자:

![](/assets/images/sqlp/sqlp-1-02-05.png)

1. TX1 트랜잭션은 Undo 세그먼트에서 트랜잭션 슬롯을 할당받고, Enqueue 리소스를 통해 TX Lock을 설정한다. 이 상태에서 r1부터 r5까지 5개 레코드를 변경하고, 아직 커밋은 하지 않았다.
2. TX2 트랜잭션도 트랜잭션 테이블에서 하나의 슬롯을 할당받고, Enqueue 리소스를 통해 TX Lock을 설정한 후 r6 레코드를 변경한다.
3. 이제 TX2가 r3 레코드를 액세스하려는 순간, 호환되지 않는 모드로 Lock이 걸려 있음을 인지하고 TX1의 트랜잭션 슬롯 상태를 확인한다.
4. TX1이 아직 커밋되지 않은 Active 상태이므로, TX2는 TX1이 설정한 TX Lock의 대기자 목록에 자신을 등록하고, 대기 상태로 들어간다.
5. TX2는 대기하면서 3초마다 한 번씩 TX1이 설정한 TX Lock의 상태를 확인한다. 교착 상태(Deadlock) 발생 여부를 확인하기 위함이다.
6. TX1이 커밋 또는 롤백하면, TX1이 설정한 TX Lock의 대기자 목록에서 가장 우선 순위가 높은 TX2 트랜잭션을 깨워 트랜잭션을 재개하도록 한다.
7. TX2는 r3 레코드를 변경한다.

v\$lock 뷰를 이용해 TX Lock 경합 상황을 모니터링할 수 있지만, 발생 원인까지 알 수는 없다. 원인을 파악하려면 v\$session_wait 또는 이벤트 트레이스(레벨 8)를 통해 대기 이벤트 발생 현황을 관찰해야 한다.

![](/assets/images/sqlp/sqlp-1-02-05-sql-2.png)

관찰된 대기 이벤트명에 따라 TX Lock을 아래와 같이 구분할 수 있다.

![](/assets/images/sqlp/sqlp-1-02-05-table-1.png)

특히, 이벤트명이 "enq: TX - row lock contention"일 때는 Lock 모드에 따라 그 발생 원인을 판단해야 한다. Lock 모드는 이벤트 발생 시 함께 기록되는 p1 파라미터를 통해 확인할 수 있다.

```
# Lock 타입(I, IX, IS, S, SX, SR, X 등)
 chr(bitand(:p1, -16777216)/16777215) || chr(bitand(:p1, 16711680)/65535)

# Lock 모드
 decode(to_char(bitand(:p1, 65535)), '0', 'None',
                                     '1', 'Null',
                                     '2', 'RS',    -- Row-Shared
                                     '3', 'RX',    -- Row-Exclusive 
                                     '4', 'S',     -- Shared
                                     '5', 'SRX',   -- Shared-Row-Exclusive
                                     '6', 'X')     -- Exclusive
```

참고로, p2, p3 파라미터를 통해 Undo 세그먼트, 트랜잭션 슬롯 번호, 그리고 Wrap 시퀀스 번호를 식별해낼 수 있다.

```
# Undo 세그먼트 번호
 trunc(:p2/power(2, 16))
# 트랜잭션 테이블 슬롯 번호
 bitand(:p2, to_number('ffff', 'xxxx')) + 0
# 트랜잭션 슬롯 Wrap 시퀀스 번호
 :p3
```

지금부터 아래 6가지 TX Lock 발생 원인에 대해 자세히 살펴보자.

- DML 로우 Lock
- 무결성 제약 위배 가능성
- 비트맵 인덱스 엔트리 갱신
- ITL 슬롯 부족
- 인덱스 분할
- 기타

이 중 가장 중요한 DML 로우 Lock은 맨 뒤에서 테이블 Lock과 함께 설명한다.


#### (3) TX Lock ▶︎ 무결성 제약 위배 가능성 또는 비트맵 인덱스 엔트리 갱신

로우 Lock 경합은 일반적으로 update나 delete 시에만 발생한다. insert는 새로운 레코드를 삽입하는 것이므로 로우 Lock 경합이 발생하지 않는다. 하지만 테이블에 Unique 인덱스가 정의되어 있을 때는 insert에 의한 로우 Lock 경합이 생길 수 있다. 두 개 이상의 트랜잭션이 같은 값을 입력하려 할 때, 선행 트랜잭션이 아직 진행 중이라면 값의 중복 여부가 확정되지 않았으므로 후행 트랜잭션은 진행을 멈추고 대기해야만 하는 것이다.

dept 테이블의 deptno 컬럼에 PK 인덱스가 생성돼 있는 상황에서 두 트랜잭션이 다음과 같이 진행하면, `enq: TX - row lock contention` 대기 이벤트가 Shared 모드로 발생한다.

1. 트랜잭션 TX1이 dept 테이블에 deptno=40인 레코드를 입력한다.
2. 트랜잭션 TX2도 dept 테이블에 deptno=40인 레코드를 입력하면, TX1이 커밋 또는 롤백할 때까지 Shared 모드로 `enq: TX - row lock contention` 대기 이벤트가 발생한다.
3. TX1이 커밋하면 TX2는 ORA-00001 에러를 만나게 된다. `"ORA-00001: 무결성 제약 조건 (PK_DEPT)에 위배됩니다"`
4. TX1이 롤백하면 TX2는 정상적으로 입력이 완료된다.

이번에는 dept와 emp 테이블이 1:M 관계고, dept.deptno를 참조하도록 emp 테이블에 FK 제약이 설정돼 있다고 가정하자. 이런 상황에서 두 트랜잭션이 아래와 같이 진행하면, 마찬가지로 `enq: TX - row lock contention` 대기 이벤트가 Shared 모드로 발생한다.

1. 트랜잭션 TX1이 dept 테이블에 deptno=40인 레코드를 삭제한다.
2. 트랜잭션 TX2가 emp 테이블에 deptno=40인 레코드를 입력하면, TX1이 커밋 또는 롤백할 때까지 Shared 모드로 `enq: TX - row lock contention` 대기 이벤트가 발생한다.
3. TX1이 커밋하면 TX2는 ORA-02291 에러를 만나게 된다. `"ORA-02291: 무결성 제약 조건 (FK_EMP_DEPT)이 위배되었습니다- 부모 키가 없습니다"`
4. TX1이 롤백하면 TX2는 정상적으로 입력이 완료된다.

비트맵 인덱스 엔트리에 대한 갱신을 수행할 때도 Shared 모드로 `enq: TX - row lock contention` 이벤트가 발생할 수 있다. 비트맵 인덱스의 구조상 하나의 엔트리가 여러 개 레코드와 매핑된다. 하나의 엔트리에 Lock을 설정하면 매핑되는 레코드 전체에 Lock이 설정되므로, 비트맵 인덱스 엔트리를 두 개 이상 트랜잭션이 동시에 갱신할 때 이 이벤트가 자주 발생한다.

예를 들어, TX1 트랜잭션이 1번 레코드를 갱신하는 동안 TX2 트랜잭션이 2번 레코드를 갱신하려고 할 수 있는데, 이때 Shared 모드로 `enq:TX - row lock contention` 대기 이벤트가 발생한다.

#### (4) TX Lock ▶︎ ITL 슬롯 부족

블록에 레코드를 추가/갱신/삭제하려면, ITL 슬롯을 먼저 할당받고 그곳에 트랜잭션 ID를 먼저 기록해야 한다. 비어 있는 ITL 슬롯이 없다면, ITL 슬롯을 사용 중인 트랜잭션 중 하나가 커밋 또는 롤백할 때까지 기다려야 하며, 이때 Shared 모드 `enq: TX - allocate ITL entry` 대기 이벤트가 발생한다. 결국, 한 블록을 동시에 갱신할 수 있는 트랜잭션 개수는 ITL 슬롯에 의해 결정된다. 참고로, ITL 슬롯 당 24바이트 공간을 차지한다.

블록에 기본적으로 할당할 ITL 슬롯 개수는 `INITRANS` 파라미터로 설정한다.

```
create table t (...) INITRANS 5 MAXTRANS 255 PCTFREE 30;
```

`PCTFREE`는 원래 컬럼 update를 위해 예약된 공간이다. 하지만 `INITRANS`에 의해 미리 할당된 ITL 슬롯이 모두 사용 중일 때, 새로운 트랜잭션이 ITL 슬롯을 요청하면 `PCTFREE` 설정에 의해 비워둔 공간을 활용하게 된다. 이 공간까지 활용해 최대한 생성할 수 있는 ITL 슬롯 개수는 `MAXTRANS`에 의해 결정된다. ITL 슬롯 부족에 의한 대기 현상이 발생했다면, 아래 둘 중 하나에 해당한다.

- 동시에 블록을 갱신하려는 트랜잭션 개수가 `MAXTRANS` 값을 초과
- `PCTFREE`를 0으로 지정했거나 `PCTFREE` 예약 공간을 모두 사용한 상태에서, 새로운 트랜잭션을 위한 ITL 슬롯이 부족

테이블에 insert할 때는, ITL 슬롯이 부족하더라도 굳이 그 블록에 insert하려고 대기할 필요가 없다. 새 블록을 할당해 그곳에 insert하면 되기 때문이며, 오라클 9i부터 그렇게 동작하기 시작했다. 따라서 9i부터는 insert 시 테이블 블록에 대한 ITL 경합이 발생하지 않는다. 하지만 인덱스에 값을 삽입할 때는 정렬 상태를 유지해야 하므로 여전히 ITL 경합이 발생한다. update, delete 때는 테이블, 인덱스를 불문하고 ITL 경합이 나타날 수 있다.

**ITL 경합에 의한 대기 현상이 자주 발생하는 세그먼트(테이블, 인덱스, 파티션)에 대해서는 `INITRANS`를 늘려주어야 하며, 그런 세그먼트 목록은 `v$segstat` 등을 통해 확인할 수 있다.**

**`INITRANS` 값을 변경하더라도 기존에 할당된 블록의 ITL 슬롯 개수에는 변함이 없고, 새로 할당되는 블록에만 적용된다. 따라서 기존 블록에서 ITL 경합이 빈번하게 발생한다면, 테이블 또는 인덱스 전체 재생성해줘야만 한다.**


(ing)

